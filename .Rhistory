# plot raster_stack to see the change of ice extent over the years
plot(
raster_stack,
col = c('white', 'lightblue'),
legend = FALSE,
)
print(results)
plot(raster_stack)
# Create the combined plot
ggplot(results, aes(x = Date)) +
# Line graph for icefield extent
geom_line(aes(y = IceExtent_km2, color = "Icefield Extent (km²)"), size = 1) +
geom_point(aes(y = IceExtent_km2, color = "Icefield Extent (km²)"), size = 2) +
geom_smooth(aes(y = IceExtent_km2, color = "lightgrey"), method = "lm", linetype = "dashed", se = FALSE) +
# Bar graph for rate of change
geom_bar(aes(y = RateOfChange_km2, fill = "Rate of Change (km²/year)"), stat = "identity", alpha = 0.5) +
# Customize scales and legend
scale_y_continuous(
name = "Icefield Extent (km²)",
sec.axis = sec_axis(~ ., name = "Rate of Change (km²/year)")
) +
scale_color_manual(
name = "",
values = c("Icefield Extent (km²)" = "blue")
) +
scale_fill_manual(
name = "",
values = c("Rate of Change (km²/year)" = "red")
) +
labs(
title = "Change in Icefield Extent and Rate of Change Over Time",
x = "Year"
) +
theme_minimal() +
theme(
axis.title.y.right = element_text(color = "red"), # Highlight secondary axis
axis.title.y.left = element_text(color = "blue"),
legend.position = "bottom",
legend.title = element_blank()
)
setwd("~/Projects/GlacierTimeSeries")
# read in polygon
icefield_extent <- st_read("~/Projects/GlacierTimeSeries/glacier_extent_shape.shp")
# read in the rasters
icefield_2004 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LT05_L2SP_0440_CompositeB.tif")
icefield_2024 <-rast("~/Projects/GlacierTimeSeries/glacier_time_series/LC09_L2SP_0450_CompositeB.tif")
# crop raster to glacier extent
icefield_2004_cropped <- crop(icefield_2004, icefield_extent)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
# mask cropped later... is this necessary?
#icefield_2004_masked <- mask(icefield_2004_cropped, icefield_extent)
#icefield_2024_masked <- mask(icefield_2024_cropped, icefield_extent)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
setwd("~/Projects/GlacierTimeSeries")
# read in polygon
icefield_extent <- st_read("~/Projects/GlacierTimeSeries/glacier_extent_shape.shp")
# read in the rasters
icefield_2004 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LT05_L2SP_0440_CompositeB.tif")
icefield_2024 <-rast("~/Projects/GlacierTimeSeries/glacier_time_series/LC09_L2SP_0450_CompositeB.tif")
# crop raster to glacier extent
icefield_2004_cropped <- crop(icefield_2004, icefield_extent)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
# mask cropped later... is this necessary?
#icefield_2004_masked <- mask(icefield_2004_cropped, icefield_extent)
#icefield_2024_masked <- mask(icefield_2024_cropped, icefield_extent)
plot(icefield_2024_cropped, r=4, g=3, b=2)
setwd("~/Projects/GlacierTimeSeries")
# read in polygon
icefield_extent <- st_read("~/Projects/GlacierTimeSeries/glacier_extent_shape.shp")
# read in the rasters
icefield_2004 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LT05_L2SP_0440_CompositeB.tif")
icefield_2024 <-rast("~/Projects/GlacierTimeSeries/glacier_time_series/LC09_L2SP_0450_CompositeB.tif")
# crop raster to glacier extent
icefield_2004_cropped <- crop(icefield_2004, icefield_extent)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
# mask cropped later... is this necessary?
#icefield_2004_masked <- mask(icefield_2004_cropped, icefield_extent)
#icefield_2024_masked <- mask(icefield_2024_cropped, icefield_extent)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
icefield_2024_cropped
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
plotRGB(icefield_2024_cropped)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
knitr::opts_chunk$set(echo = TRUE)
library(raster)
library(terra)
library(sf)
library(ggplot2)
library(dplyr)
library(lubridate)
library(stringr)
setwd("~/Projects/GlacierTimeSeries")
# read in polygon
icefield_extent <- st_read("~/Projects/GlacierTimeSeries/glacier_extent_shape.shp")
# read in the rasters
icefield_2004 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LT05_L2SP_0440_CompositeB.tif")
icefield_2024 <-rast("~/Projects/GlacierTimeSeries/glacier_time_series/LC09_L2SP_0450_CompositeB.tif")
# crop raster to glacier extent
icefield_2004_cropped <- crop(icefield_2004, icefield_extent)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
# mask cropped later... is this necessary?
#icefield_2004_masked <- mask(icefield_2004_cropped, icefield_extent)
#icefield_2024_masked <- mask(icefield_2024_cropped, icefield_extent)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
# extract green and SWIR bands for 2004 landsat 5
green_2004 <- icefield_2004_cropped[[2]]
swir_2004 <- icefield_2004_cropped[[5]]
# extract green and SWIR bands for 2024 landsat 9
green_2024 <- icefield_2024_cropped[[3]]
swir_2024 <- icefield_2024_cropped[[6]]
# calculate NDSI for each year
ndsi_2004 <- ((green_2004 - swir_2004) / (green_2004 + swir_2004))
ndsi_2024 <- ((green_2024 - swir_2024) / (green_2024 + swir_2024))
plot(ndsi_2004,
main = "NDSI of Columbia Ice Field in 2004")
# extract what is ice from raster using NDSI. Generally values above 0.4 are ice. I used 0.35 to get a little more.
ice_2004 <- ndsi_2004 > 0.35
ice_2024 <- ndsi_2024 > 0.35
# plot
plot(ice_2004)
plot(ice_2024)
change_extent <- ice_2024 - ice_2004
plot(change_extent)
# calculating the area in square meters of the change of glacier surface area
cell_size <- res(ice_2004)[1] * res(ice_2004)[2]
loss_area <- sum(change_extent[] == -1, na.rm = TRUE) * cell_size
gain_area <- sum(change_extent[] == 1, na.rm = TRUE) * cell_size
print(paste("Glacier loss area (m²):", loss_area))
print(paste("Glacier gain area (m²):", gain_area))
total_change <- gain_area - loss_area
print(paste("Glacier gain change (m²):", total_change))
area_2004 <- (sum(values(ice_2004) == 1, na.rm = TRUE)) * cell_size
area_2024 <- (sum(values(ice_2024) == 1, na.rm = TRUE)) * cell_size
glacier_area <- data.frame(
Year = c(2004, 2024),
Area_km2 = c(area_2004, area_2024) / 1e6)
ggplot(glacier_area, aes(x = Year, y = Area_km2)) +
geom_line() + geom_point() +
labs(title = "Glacier Area Change Over Time", x = "Year", y = "Area (km²)")
# first i need to crop the landsat images and create NDSI composites for each year i have data for
base_dir <- "~/Projects/GlacierTimeSeries/data"
output_dir <- "~/Projects/GlacierTimeSeries/output"
# before we begin doing anything, we need to understand that we are using different LANDSATs.
# The implication of this is that the band numbers represent specific wavelengths,
# and are not the same across the different LANDSAT. notably between LANDSAT5 and the other, later models.
# Thus, before we begin, I need to define which landsat is being used and
# apply a function based on the naming of the file (which is how we can find out which landsat is)
# Define Landsat band mappings for Green and SWIR bands
landsat_band_mapping <- list(
"LANDSAT_5" = list(green = 2, swir = 5),
"LANDSAT_7" = list(green = 2, swir = 5),
"LANDSAT_8" = list(green = 3, swir = 6),
"LANDSAT_9" = list(green = 3, swir = 6)
)
# Function to detect Landsat type based on product ID or file names
detect_landsat <- function(product_id) {
if (grepl("LC09", product_id)) return("LANDSAT_9")
if (grepl("LC08", product_id)) return("LANDSAT_8")
if (grepl("LE07", product_id)) return("LANDSAT_7")
if (grepl("LT05", product_id)) return("LANDSAT_5")
stop("Unknown Landsat type in product_id: ", product_id)
}
# Main loop to process all directories
for (n in list.dirs(base_dir, full.names = TRUE, recursive = FALSE)) {
# Get all TIF files in the directory
tif_files <- list.files(n, pattern = ".TIF$", full.names = TRUE)
# Extract product ID from directory name
product_id <- basename(n)
# Detect Landsat type based on product ID
landsat_type <- detect_landsat(product_id)
bands <- landsat_band_mapping[[landsat_type]] # Get the correct bands for this Landsat type
# Filter surface reflectance bands and QA_PIXEL band
sr_bands <- tif_files[str_detect(basename(tif_files), "SR_B[1-7]")]
qa_pixel <- tif_files[str_detect(basename(tif_files), "QA_PIXEL")]
# Load the surface reflectance stack
sr_stack <- rast(sr_bands)
# Crop the glacier polygon to the raster
icefield_extent_utm <- st_transform(icefield_extent, crs(sr_stack)) # Ensure CRS match
sr_stack_cropped <- crop(sr_stack, vect(icefield_extent_utm))
# Calculate NDSI using the dynamically selected Green and SWIR bands
calc_ndsi <- (sr_stack_cropped[[bands$green]] - sr_stack_cropped[[bands$swir]]) /
(sr_stack_cropped[[bands$green]] + sr_stack_cropped[[bands$swir]])
# Save the NDSI output raster
ndsi_output <- paste0(output_dir, "/", product_id, "_NDSI.tif")
writeRaster(calc_ndsi, ndsi_output, overwrite = TRUE)
}
# create loop for calculating area for each NDSI tif file
output_files <- list.files(output_dir, pattern = "NDSI.tif$", full.names = TRUE, recursive = FALSE)
# extract the date from the file name
# example file naming structure:
# "~ LC08_L2SP_044024_20210812_20210819_02_T1_NDSI.tif"
ndsi_date <- str_extract(output_files, "\\d{8}")
years <- sort(ymd(ndsi_date))
# create empty data frame to store the calculated values
results <- data.frame(Date = as.Date(character()), IceExtent_km2 = numeric(), RateOfChange_km2 = numeric())
# start the for loop for each file in directory
for (n in seq_along(output_files)) {
# read each tif into a raster
ndsi_raster <- rast(output_files[n])
# extract the extent of the ice (im using a ndsi value of 0.35)
ice_raster <- ndsi_raster > 0.35
# calculate the extent using the pixel size (30m x 30m) that we already calulcated before
ice_extent <- sum(values(ice_raster), na.rm = TRUE) * cell_size
# convert it into kilometers squared
ice_extent_km2 <- ice_extent / 1e6
# calculate rate of change of each year
if (n > 1) {
rate_of_change <- ice_extent_km2 - results$IceExtent_km2[n - 1]
} else {
rate_of_change <- NA  # No rate of change for the first year
}
# bind the results to the initial data.frame
results <- rbind(results, data.frame(Date = years[n], IceExtent_km2 = ice_extent_km2, RateOfChange_km2 = rate_of_change))
}
# I also want to plot the rasters together in one plot so we can visually see the NDSI change over the years
raster_stack <- rast()
for (n in seq_along(output_files)) {
ndsi_raster <- rast(output_files[n])
ice_raster <- ndsi_raster > 0.35
names(ice_raster) <- format(years[n], "%Y")
raster_stack <- c(raster_stack, ice_raster)
}
# order the raster_stack by years
years_ordered <- order(years)
raster_stack <- raster_stack[[years_ordered]]
# plot raster_stack to see the change of ice extent over the years
plot(
raster_stack,
col = c('white', 'lightblue'),
legend = FALSE,
)
print(results)
plot(raster_stack)
# Create the combined plot
ggplot(results, aes(x = Date)) +
# Line graph for icefield extent
geom_line(aes(y = IceExtent_km2, color = "Icefield Extent (km²)"), size = 1) +
geom_point(aes(y = IceExtent_km2, color = "Icefield Extent (km²)"), size = 2) +
geom_smooth(aes(y = IceExtent_km2, color = "lightgrey"), method = "lm", linetype = "dashed", se = FALSE) +
# Bar graph for rate of change
geom_bar(aes(y = RateOfChange_km2, fill = "Rate of Change (km²/year)"), stat = "identity", alpha = 0.5) +
# Customize scales and legend
scale_y_continuous(
name = "Icefield Extent (km²)",
sec.axis = sec_axis(~ ., name = "Rate of Change (km²/year)")
) +
scale_color_manual(
name = "",
values = c("Icefield Extent (km²)" = "blue")
) +
scale_fill_manual(
name = "",
values = c("Rate of Change (km²/year)" = "red")
) +
labs(
title = "Change in Icefield Extent and Rate of Change Over Time",
x = "Year"
) +
theme_minimal() +
theme(
axis.title.y.right = element_text(color = "red"), # Highlight secondary axis
axis.title.y.left = element_text(color = "blue"),
legend.position = "bottom",
legend.title = element_blank()
)
View(icefield_2004)
terra::plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
setwd("~/Projects/GlacierTimeSeries")
# read in polygon
icefield_extent <- st_read("~/Projects/GlacierTimeSeries/glacier_extent_shape.shp")
# read in the rasters
icefield_2004 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LT05_L2SP_0440_CompositeB.tif")
icefield_2024 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LC09_L2SP_0450_CompositeB.tif")
# crop raster to glacier extent
icefield_2004_cropped <- crop(icefield_2004, icefield_extent)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
# mask cropped later... is this necessary?
#icefield_2004_masked <- mask(icefield_2004_cropped, icefield_extent)
#icefield_2024_masked <- mask(icefield_2024_cropped, icefield_extent)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
setwd("~/Projects/GlacierTimeSeries")
# read in polygon
icefield_extent <- st_read("~/Projects/GlacierTimeSeries/glacier_extent_shape.shp")
# read in the rasters
icefield_2004 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LT05_L2SP_0440_CompositeB.tif")
icefield_2024 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LC09_L2SP_0450_CompositeB.tif")
# crop raster to glacier extent
icefield_2004_cropped <- crop(icefield_2004, icefield_extent)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
plotRGB(icefield_2024_cropped, r=4, g=3, b=2)
setwd("~/Projects/GlacierTimeSeries")
# read in polygon
icefield_extent <- st_read("~/Projects/GlacierTimeSeries/glacier_extent_shape.shp")
# read in the rasters
icefield_2004 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LT05_L2SP_0440_CompositeB.tif")
icefield_2024 <- rast("~/Projects/GlacierTimeSeries/glacier_time_series/LC09_L2SP_0450_CompositeB.tif")
# crop raster to glacier extent
icefield_2004_cropped <- crop(icefield_2004, icefield_extent)
icefield_2024_cropped <- crop(icefield_2024, icefield_extent)
plotRGB(icefield_2024_cropped, r=4, g=3, b=1)
knitr::opts_chunk$set(echo = TRUE)
# create 5m resolution DEM
cat_afrf <- readLAScatalog("~/GEM 521/Lab 4/L4_Data/LAS") # create LAS catalog object from AFRF las tiles
las_check(cat_afrf) # inspect the details of the .las catalog
summary(cat_afrf) # get a brief summary of the catalog
# create 5m resolution DEM
cat_afrf <- readLAScatalog("~/GEM 521/Lab 4/L4_Data/LAS") # create LAS catalog object from AFRF las tiles
las_check(cat_afrf) # inspect the details of the .las catalog
summary(cat_afrf) # get a brief summary of the catalog
plot(cat_afrf)
col_dem <- height.colors(50) # create specific color ramp for DEM
plot(dem_allLAS_afrf, col = col_dem) # plot DEM in 2D
library(lidR)
library(terra)
library(tidyr)
library(tidyverse)
work_dir <- "~/GEM 521/Lab 4/L4_Data"
setwd(work_dir)
# create 5m resolution DEM
cat_afrf <- readLAScatalog("~/GEM 521/Lab 4/L4_Data/LAS") # create LAS catalog object from AFRF las tiles
las_check(cat_afrf) # inspect the details of the .las catalog
summary(cat_afrf) # get a brief summary of the catalog
plot(cat_afrf)
tile1_afrf <- readLAS("~/GEM 521/Lab 4/L4_Data/LAS/AFRF_Tile1.las") # read in one of the tiles
las_check(tile1_afrf)
dem_allLAS_afrf <- rasterize_terrain(cat_afrf, 2, tin()) # rasterize the .las files in the catalog
col_dem <- height.colors(50) # create specific color ramp for DEM
plot(dem_allLAS_afrf, col = col_dem) # plot DEM in 2D
opt_output_files(cat_afrf) <- paste(work_dir, "~/GEM 521/Lab 4/L4_Data/Normalized LAS/norm_afrf_{ID}", sep = "") # set up output directory with naming convention
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_mkrf) # check folder when complete
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_afrf) # check folder when complete
opt_filter(cat_afrf) <- 'drop_z_below 0 -drop_z_above 55'
chm_afrf <- rasterize_canopy(cat_afrf, 2, p2r())
opt_output_files(cat_afrf) <- paste(work_dir, "~/GEM 521/Lab 4/L4_Data/Normalized LAS/norm_afrf_{ID}", sep = "") # set up output directory with naming convention
opt_filter(cat_afrf) <- 'drop_z_below 0 -drop_z_above 55'
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_afrf) # check folder when complete
chm_afrf <- rasterize_canopy(cat_afrf, 2, p2r())
View(cat_afrf)
help('rasterize_canopy'
)
knitr::opts_chunk$set(echo = TRUE)
# define LAScatalog engine options
opt_output_files(filtered_cat_mkrf) <- paste(wd, "~/GEM 521/Lab 2/Data/Normalized/norm_mkrf_{ID}", sep = "")
opt_output_files(cat_afrf) <- paste(work_dir, "~/GEM 521/Lab 4/L4_Data/Normalized LAS/norm_afrf_{ID}", sep = "") # set up output directory with naming convention
library(lidR)
library(terra)
library(tidyr)
library(tidyverse)
work_dir <- "C:/Users/lorsigno.stu/OneDrive - UBC/Desktop/Documents/GEM 521/Lab 4/L4_Data"
setwd(work_dir)
opt_output_files(cat_afrf) <- paste(work_dir, "~/GEM 521/Lab 4/L4_Data/Normalized LAS/norm_afrf_{ID}", sep = "") # set up output directory with naming convention
opt_filter(cat_afrf) <- 'drop_z_below 0 -drop_z_above 55'
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_afrf) # check folder when complete
setwd("C:/Users/lorsigno.stu/OneDrive - UBC/Desktop/Documents/GEM 521/Lab 4/L4_Data")
library(lidR)
library(terra)
library(tidyr)
library(tidyverse)
# set working directory
setwd("C:/Users/lorsigno.stu/OneDrive - UBC/Desktop/Documents/GEM 521/Lab 4/L4_Data")
# create variable string of wd
wd <- "C:/Users/lorsigno.stu/OneDrive - UBC/Desktop/Documents/GEM 521/Lab 4/L4_Data"
opt_output_files(cat_afrf) <- paste(wd, "~/GEM 521/Lab 4/L4_Data/Normalized LAS/norm_afrf_{ID}", sep = "") # set up output directory with naming convention
opt_filter(cat_afrf) <- 'drop_z_below 0 -drop_z_above 55'
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_afrf) # check folder when complete
# create 5m resolution DEM
cat_afrf <- readLAScatalog("/GEM 521/Lab 4/L4_Data/LAS") # create LAS catalog object from AFRF las tiles
opt_filter(cat_afrf) <- 'drop_z_below 0 -drop_z_above 55'
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_afrf) # check folder when complete
col_dem <- height.colors(50) # create specific color ramp for DEM
plot(dem_allLAS_afrf, col = col_dem) # plot DEM in 2D
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_afrf) # check folder when complete
chm_afrf <- rasterize_canopy(cat_afrf, 2, p2r())
plot(chm_afrf, col = col_1)
library(lidR)
library(terra)
library(tidyr)
library(tidyverse)
# set working directory
setwd("C:/Users/lorsigno.stu/OneDrive - UBC/Desktop/Documents/GEM 521/Lab 4/L4_Data")
# create working directory variable
wd <- "C:/Users/lorsigno.stu/OneDrive - UBC/Desktop/Documents/GEM 521/Lab 4/L4_Data"
cat_afrf <- readLAScatalog("~/GEM 521/Lab 4/L4_Data/LAS") # create LAS catalog object from AFRF las tiles
las_check(cat_afrf) # inspect the details of the .las catalog
summary(cat_afrf) # get a brief summary of the catalog
plot(cat_afrf)
tile1_afrf <- readLAS("~/GEM 521/Lab 4/L4_Data/LAS/AFRF_Tile1.las") # read in one of the tiles
las_check(tile1_afrf)
cat_afrf <- readLAScatalog(wd, "/LAS/AFRF_Tile1.las") # create LAS catalog object from AFRF las tiles
cat_afrf <- readLAScatalog(paste0(wd, "/LAS/AFRF_Tile1.las")) # create LAS catalog object from AFRF las tiles
las_check(cat_afrf) # inspect the details of the .las catalog
cat_afrf <- readLAScatalog(paste0(wd, "/LAS")) # create LAS catalog object from AFRF las tiles
las_check(cat_afrf) # inspect the details of the .las catalog
summary(cat_afrf) # get a brief summary of the catalog
plot(cat_afrf)
tile1_afrf <- readLAS(paste0(wd, "/LAS/AFRF_Tile1.las"))  # Load a single tile
las_check(tile1_afrf)  # Check for duplicates
dem_allLAS_afrf <- rasterize_terrain(cat_afrf, 2, tin()) # rasterize the .las files in the catalog
dem_allLAS_afrf <- rasterize_terrain(cat_afrf, 2, tin()) # rasterize the .las files in the catalog
col_dem <- height.colors(50) # create specific color ramp for DEM
plot(dem_allLAS_afrf, col = col_dem) # plot DEM in 2D
output_dir <- paste0(wd, "/Normalized LAS")
# set up output directory with naming convention
opt_output_files(cat_afrf) <- paste(output_dir, "/norm_afrf_{ID}")
# filter out ground and outliers
opt_filter(cat_afrf) <- 'drop_z_below 0 -drop_z_above 55'
norm_tiles_afrf <- normalize_height(cat_afrf, dem_allLAS_afrf) # check folder when complete
output_dir
cat_afrf
norm_tiles_afrf
source("~/.active-rstudio-document", echo=TRUE)
# Load the spatial data
oecm_data <- st_read("C:\Users\lorsigno.stu\OneDrive - UBC\Desktop\Documents\GitHub\E-Portfolio\data\HoweSound_Weig_FeaturesToJSO.geojson")
warnings()
warnings()
install.packages(dpl)
install.packages(leaflet)
install.packages(sf)
library(dplyr)
library(leaflet)
library(sf)
# Load the spatial data
oecm_data <- st_read("data/HoweSound_Weig_FeaturesToJSO.geojson")
# Check CRS and reproject to WGS84 if necessary
if (st_crs(oecm_data)$epsg != 4326) {
oecm_data <- st_transform(oecm_data, crs = 4326)
}
# Validate the geometry
oecm_data <- st_make_valid(oecm_data)
# Define a color palette based on a column (e.g., "CategoryColumn")
pal <- colorNumeric(palette = "YlGnBu", domain = oecm_data$total_weig)
# Create the map
main_map <- leaflet(oecm_data) %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
color = ~pal(oecm_data$total_weig), # Color based on column
weight = 1,
fillOpacity = 0.7,
label = ~paste0("Category: ", oecm_data$total_weig) # Tooltip
) %>%
setView(lng = -123.155, lat = 49.7016, zoom = 12) # Center on Squamish
main_map
install.packages("dplyr")
install.packages("leaflet")
install.packages("sf")
library(dplyr)
library(leaflet)
library(sf)
# Load the spatial data
oecm_data <- st_read("data/HoweSound_Weig_FeaturesToJSO.geojson")
install.packages("dplyr")
install.packages("leaflet")
install.packages("sf")
library(dplyr)
library(leaflet)
library(sf)
# Load the spatial data
oecm_data <- st_read("data/HoweSound_Weig_FeaturesToJSO.geojson")
# Check CRS and reproject to WGS84 if necessary
if (st_crs(oecm_data)$epsg != 4326) {
oecm_data <- st_transform(oecm_data, crs = 4326)
}
# Validate the geometry
oecm_data <- st_make_valid(oecm_data)
# Define a color palette based on a column (e.g., "CategoryColumn")
pal <- colorNumeric(palette = "YlGnBu", domain = oecm_data$total_weig)
# Create the map
main_map <- leaflet(oecm_data) %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
color = ~pal(oecm_data$total_weig), # Color based on column
weight = 1,
fillOpacity = 0.7,
label = ~paste0("Category: ", oecm_data$total_weig) # Tooltip
) %>%
setView(lng = -123.155, lat = 49.7016, zoom = 12) # Center on Squamish
library(dplyr)
library(leaflet)
library(sf)
# Load the spatial data
oecm_data <- st_read("data/HoweSound_Weig_FeaturesToJSO.geojson")
# Check CRS and reproject to WGS84 if necessary
if (st_crs(oecm_data)$epsg != 4326) {
oecm_data <- st_transform(oecm_data, crs = 4326)
}
# Validate the geometry
if (!is.null(oecm_data) && nrow(oecm_data) > 0) {
oecm_data <- st_make_valid(oecm_data)
}
# Define a color palette based on a column (e.g., "CategoryColumn")
pal <- colorNumeric(palette = "YlGnBu", domain = oecm_data$total_weig)
# Create the map
main_map <- leaflet(oecm_data) %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
color = ~pal(oecm_data$total_weig), # Color based on column
weight = 1,
fillOpacity = 0.7,
label = ~paste0("Category: ", oecm_data$total_weig) # Tooltip
) %>%
setView(lng = -123.155, lat = 49.7016, zoom = 12) # Center on Squamish
warnings()
warnings()
warnings()
quarto preview
quarto check
## OECM Land Suitability Mesh Layer
Each hexagon has a value based on the ecological sensitivity, critical habitat, forest age, proximity to streams and slope steepness. Darker values represent more sensitive areas and are used to select parcels of land from the BC Parcel Fabric layer in order to locate pieces of land that could be considered as OECM.
warnings()
